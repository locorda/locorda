// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: lib/models/note_index_entry.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'package:personal_notes_app/models/note_index_entry.dart' as nie;
import 'package:locorda_core/locorda_core.dart';
import 'package:rdf_vocabularies_schema/schema.dart';
import 'package:personal_notes_app/vocabulary/personal_notes_vocab.dart' as pnv;
import 'package:personal_notes_app/models/category.dart' as category;
import 'package:personal_notes_app/models/note.dart';

/// Generated mapper for [nie.NoteIndexEntry] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `nie.NoteIndexEntry`.
class NoteIndexEntryMapper implements LocalResourceMapper<nie.NoteIndexEntry> {
  final IriTermMapper<String> _categoryIdMapper;
  final IriTermMapper<String> _idMapper;

  /// Constructor
  const NoteIndexEntryMapper({
    required IriTermMapper<String> categoryIdMapper,
    required IriTermMapper<String> idMapper,
  }) : _categoryIdMapper = categoryIdMapper,
       _idMapper = idMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  nie.NoteIndexEntry fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String id = reader.require(
      IdxShardEntry.resource,
      deserializer: _idMapper,
    );
    final String name = reader.require(SchemaNoteDigitalDocument.name);
    final DateTime dateCreated = reader.require(
      SchemaNoteDigitalDocument.dateCreated,
    );
    final DateTime dateModified = reader.require(
      SchemaNoteDigitalDocument.dateModified,
    );
    final Set<String> keywords = reader.requireCollection<Set<String>, String>(
      SchemaNoteDigitalDocument.keywords,
      UnorderedItemsSetMapper.new,
    );
    final String? categoryId = reader.optional(
      pnv.PersonalNotesVocab.belongsToCategory,
      deserializer: _categoryIdMapper,
    );

    return nie.NoteIndexEntry(
      id: id,
      name: name,
      dateCreated: dateCreated,
      dateModified: dateModified,
      keywords: keywords,
      categoryId: categoryId,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    nie.NoteIndexEntry resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(IdxShardEntry.resource, resource.id, serializer: _idMapper)
        .addValue(SchemaNoteDigitalDocument.name, resource.name)
        .addValue(SchemaNoteDigitalDocument.dateCreated, resource.dateCreated)
        .addValue(SchemaNoteDigitalDocument.dateModified, resource.dateModified)
        .addCollection<Set<String>, String>(
          SchemaNoteDigitalDocument.keywords,
          resource.keywords,
          UnorderedItemsSetMapper.new,
        )
        .when(
          resource.categoryId != null,
          (b) => b.addValue(
            pnv.PersonalNotesVocab.belongsToCategory,
            resource.categoryId,
            serializer: _categoryIdMapper,
          ),
        )
        .build();
  }
}
