// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: lib/rdf_iri_classes.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'package:mapper_annotations_examples/rdf_iri_classes.dart' as ric;

/// Generated mapper for [ric.ISBN] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `ric.ISBN`.
class ISBNMapper implements IriTermMapper<ric.ISBN> {
  static final RegExp _regex = RegExp(r'^urn:isbn:(?<value>[^/]*)$');

  /// Constructor
  const ISBNMapper();

  @override
  ric.ISBN fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['value'];
    if (value == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return ric.ISBN(value);
  }

  @override
  IriTerm toRdfTerm(
    ric.ISBN iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    return context.createIriTerm('urn:isbn:${value}');
  }
}

/// Generated mapper for [ric.AbsoluteUri] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `ric.AbsoluteUri`.
class AbsoluteUriMapper implements IriTermMapper<ric.AbsoluteUri> {
  static final RegExp _regex = RegExp(r'^(?<uri>.*)$');

  /// Constructor
  const AbsoluteUriMapper();

  @override
  ric.AbsoluteUri fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final uri = iriParts['uri'];
    if (uri == null) {
      throw DeserializationException(
        'Missing required IRI part: uri in IRI ${term.value}',
      );
    }

    return ric.AbsoluteUri(uri);
  }

  @override
  IriTerm toRdfTerm(
    ric.AbsoluteUri iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final uri = iriTermValue.uri;
    return context.createIriTerm('${uri}');
  }
}

/// Generated mapper for [ric.CollectionItem] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `ric.CollectionItem`.
class CollectionItemMapper implements IriTermMapper<ric.CollectionItem> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/collections/(?<collection>[^/]*)/(?<item>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const CollectionItemMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  ric.CollectionItem fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final collection = iriParts['collection'];
    if (collection == null) {
      throw DeserializationException(
        'Missing required IRI part: collection in IRI ${term.value}',
      );
    }
    final item = iriParts['item'];
    if (item == null) {
      throw DeserializationException(
        'Missing required IRI part: item in IRI ${term.value}',
      );
    }

    return ric.CollectionItem(collection, item);
  }

  @override
  IriTerm toRdfTerm(
    ric.CollectionItem iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final collection = iriTermValue.collection;
    final item = iriTermValue.item;
    final baseUri = _baseUriProvider();
    return context.createIriTerm(
      '${baseUri}/collections/${collection}/${item}',
    );
  }
}
