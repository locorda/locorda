// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: lib/models/category.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'package:personal_notes_app/models/category.dart' as category;
import 'package:personal_notes_app/vocabulary/personal_notes_vocab.dart';
import 'package:rdf_vocabularies_schema/schema.dart';
import 'package:personal_notes_app/models/category_display_settings.dart';
import 'package:locorda_core/locorda_core.dart' as locorda_core;

/// Generated mapper for [category.Category] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `category.Category`.
class CategoryMapper implements GlobalResourceMapper<category.Category> {
  final IriTermMapper<(String id,)> _iriMapper;

  /// Constructor
  const CategoryMapper({required IriTermMapper<(String id,)> iriMapper})
    : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => PersonalNotesVocab.NotesCategory;

  @override
  category.Category fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final (id,) = _iriMapper.fromRdfTerm(subject, context);

    final String name = reader.require(SchemaCreativeWork.name);
    final String? description = reader.optional(SchemaCreativeWork.description);
    final CategoryDisplaySettings? settings = reader.optional(
      PersonalNotesVocab.displaySettings,
    );
    final DateTime createdAt = reader.require(SchemaCreativeWork.dateCreated);
    final DateTime modifiedAt = reader.require(SchemaCreativeWork.dateModified);
    final bool archived = reader.require(PersonalNotesVocab.archived);

    // Get unmapped triples as the last reader operation for lossless mapping
    final RdfGraph other = reader.getUnmapped<RdfGraph>(globalUnmapped: true);

    return category.Category(
      id: id,
      name: name,
      description: description,
      settings: settings,
      createdAt: createdAt,
      modifiedAt: modifiedAt,
      archived: archived,
      other: other,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    category.Category resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm((resource.id,), context);

    return context
        .resourceBuilder(subject)
        .addValue(SchemaCreativeWork.name, resource.name)
        .when(
          resource.description != null,
          (b) =>
              b.addValue(SchemaCreativeWork.description, resource.description),
        )
        .when(
          resource.settings != null,
          (b) =>
              b.addValue(PersonalNotesVocab.displaySettings, resource.settings),
        )
        .addValue(SchemaCreativeWork.dateCreated, resource.createdAt)
        .addValue(SchemaCreativeWork.dateModified, resource.modifiedAt)
        .addValue(PersonalNotesVocab.archived, resource.archived)
        .addUnmapped(resource.other)
        .build();
  }
}
