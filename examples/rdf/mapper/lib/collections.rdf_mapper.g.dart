// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: lib/collections.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'package:rdf_mapper_examples/collections.dart' as collections;
import 'package:locorda_rdf_terms_schema/schema.dart';

/// Generated mapper for [collections.Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `collections.Book`.
class BookMapper implements GlobalResourceMapper<collections.Book> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/books/(?<isbn>[^/]*)$');

  final String Function() _baseUriProvider;

  /// Constructor
  const BookMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  collections.Book fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final isbn = iriParts['isbn'];
    if (isbn == null) {
      throw DeserializationException(
        'Missing required IRI part: isbn in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaBook.name);
    final List<collections.Chapter> chapters = reader
        .requireCollection<List<collections.Chapter>, collections.Chapter>(
          SchemaBook.hasPart,
          RdfListMapper.new,
        );
    final Set<String> keywords = reader.requireCollection<Set<String>, String>(
      SchemaBook.keywords,
      UnorderedItemsSetMapper.new,
    );
    final Map<String, collections.Review> reviews = reader
        .collect<collections.ReviewEntry, Map<String, collections.Review>>(
          SchemaBook.review,
          (it) => {for (var vc in it) vc.reviewer: vc.rating},
        );

    return collections.Book(
      isbn: isbn,
      title: title,
      chapters: chapters,
      keywords: keywords,
      reviews: reviews,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    collections.Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addCollection<List<collections.Chapter>, collections.Chapter>(
          SchemaBook.hasPart,
          resource.chapters,
          RdfListMapper.new,
        )
        .addCollection<Set<String>, String>(
          SchemaBook.keywords,
          resource.keywords,
          UnorderedItemsSetMapper.new,
        )
        .addValues<collections.ReviewEntry>(
          SchemaBook.review,
          resource.reviews.entries.map(
            (e) => collections.ReviewEntry(reviewer: e.key, rating: e.value),
          ),
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(collections.Book resource) {
    final isbn = resource.isbn;
    final baseUri = _baseUriProvider();
    return '${baseUri}/books/${isbn}';
  }
}

/// Generated mapper for [collections.Chapter] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `collections.Chapter`.
class ChapterMapper implements LocalResourceMapper<collections.Chapter> {
  /// Constructor
  const ChapterMapper();

  @override
  IriTerm? get typeIri => SchemaChapter.classIri;

  @override
  collections.Chapter fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String title = reader.require(SchemaChapter.name);
    final int number = reader.require(SchemaChapter.position);

    return collections.Chapter(title: title, number: number);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    collections.Chapter resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaChapter.name, resource.title)
        .addValue(SchemaChapter.position, resource.number)
        .build();
  }
}

/// Generated mapper for [collections.ReviewEntry] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `collections.ReviewEntry`.
class ReviewEntryMapper
    implements LocalResourceMapper<collections.ReviewEntry> {
  /// Constructor
  const ReviewEntryMapper();

  @override
  IriTerm? get typeIri => SchemaReview.classIri;

  @override
  collections.ReviewEntry fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String reviewer = reader.require(SchemaReview.author);
    final collections.Review rating = reader.require(SchemaReview.reviewRating);

    return collections.ReviewEntry(reviewer: reviewer, rating: rating);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    collections.ReviewEntry resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaReview.author, resource.reviewer)
        .addValue(SchemaReview.reviewRating, resource.rating)
        .build();
  }
}

/// Generated mapper for [collections.Review] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `collections.Review`.
class ReviewMapper implements LocalResourceMapper<collections.Review> {
  /// Constructor
  const ReviewMapper();

  @override
  IriTerm? get typeIri => SchemaRating.classIri;

  @override
  collections.Review fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final int stars = reader.require(SchemaRating.ratingValue);

    return collections.Review(stars: stars);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    collections.Review resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaRating.ratingValue, resource.stars)
        .build();
  }
}
