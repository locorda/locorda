// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: lib/advanced.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'package:rdf_mapper_examples/advanced.dart' as advanced;
import 'package:locorda_rdf_terms_schema/schema.dart';
import 'package:locorda_rdf_terms_core/rdf.dart' as rdf;

/// Generated mapper for [advanced.Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `advanced.Book`.
class BookMapper implements GlobalResourceMapper<advanced.Book> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/books/(?<isbn>[^/]*)$');

  final String Function() _baseUriProvider;
  final LiteralTermMapper<String> _descriptionMapper;

  /// Constructor
  const BookMapper({
    required String Function() baseUriProvider,
    LiteralTermMapper<String> descriptionMapper =
        const LanguageOverrideMapper<String>('en'),
  }) : _baseUriProvider = baseUriProvider,
       _descriptionMapper = descriptionMapper;

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  advanced.Book fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final isbn = iriParts['isbn'];
    if (isbn == null) {
      throw DeserializationException(
        'Missing required IRI part: isbn in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaBook.name);
    final advanced.BookFormat format = reader.require(SchemaBook.bookFormat);
    final String description = reader.require(
      SchemaBook.description,
      deserializer: _descriptionMapper,
    );

    return advanced.Book(
      isbn: isbn,
      title: title,
      format: format,
      description: description,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    advanced.Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addValue(SchemaBook.bookFormat, resource.format)
        .addValue(
          SchemaBook.description,
          resource.description,
          serializer: _descriptionMapper,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(advanced.Book resource) {
    final isbn = resource.isbn;
    final baseUri = _baseUriProvider();
    return '${baseUri}/books/${isbn}';
  }
}

/// Generated mapper for [advanced.ISBN] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type advanced.ISBN.
class ISBNMapper implements LiteralTermMapper<advanced.ISBN> {
  final IriTerm? datatype = null;

  const ISBNMapper();

  @override
  advanced.ISBN fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    final String value = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck: bypassDatatypeCheck,
    );

    return advanced.ISBN(value);
  }

  @override
  LiteralTerm toRdfTerm(
    advanced.ISBN value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.value);
  }
}

/// Generated mapper for [advanced.BookFormat] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type advanced.BookFormat.
class BookFormatMapper implements IriTermMapper<advanced.BookFormat> {
  static final RegExp _regex = RegExp(
    r'^https://schema\.org/BookFormatType/(?<value>[^/]*)$',
  );

  /// Constructor
  const BookFormatMapper();

  @override
  advanced.BookFormat fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException(
        'Unknown advanced.BookFormat IRI: ${term.value}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'Hardcover' => advanced.BookFormat.hardcover,
      'Paperback' => advanced.BookFormat.paperback,
      'EBook' => advanced.BookFormat.ebook,
      _ => throw DeserializationException(
        'Unknown advanced.BookFormat IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    advanced.BookFormat value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    advanced.BookFormat.hardcover => context.createIriTerm(
      _buildIri('Hardcover'),
    ),
    advanced.BookFormat.paperback => context.createIriTerm(
      _buildIri('Paperback'),
    ),
    advanced.BookFormat.ebook => context.createIriTerm(_buildIri('EBook')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'https://schema.org/BookFormatType/${value}';
  }
}
